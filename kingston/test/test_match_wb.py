# yapf

import pytest

from typing import Any, Iterable, Mapping

from hypothesis import given
from hypothesis import settings

from kingston.testing import fixture
from kingston.decl import unbox

from kingston.match import (match, match_subtype, matches, move, Matcher,
                            TypeMatcher, ValueMatcher, Miss, Mismatch,
                            Conflict)

from kingston.match import (matches, match, move, Matcher, TypeMatcher,
                            ValueMatcher, Miss, Mismatch, Conflict)

from kingston.testing import between, diff_ints, same

pytestmark = pytest.mark.wbox


@fixture.params(
    "value, pattern, expected",
    (1, 1, True),
    ('x', 1, False),
    (1.1, 1, False),
    (object(), 1, False),
    (TypeMatcher(), 1, False),
    ((1,2,3), (1,2,3), True),
)  # yapf: disable
def test_match(value, pattern, expected) -> None:
    "Should match_hit"
    assert match(value, pattern) == expected


@fixture.params(
    "value, pattern, expected",
    (int, int, True),
    (int, float, False),
    # (1.0, 5.0, True),
    ((int, ), tuple, True),
    ((float, ), list, False),
    # (int, tuple, False),
    # ((int, ), list, False),
    # ((1, ), list, False),
)
def test_match_subtype(value, pattern, expected) -> None:
    "Should match_subtype"
    assert match_subtype(value, pattern) == expected


@fixture.params(
    "l,p,xl,xp",
    # : naive-hit
    ((1,2), (1,2), (2,), (2,)),
    ((2,), (2,), (), ()),
    # : naive-miss
    ((1,3), (Any,4), (3,), (4,)),
    ((3,), (4,), Miss, Miss),
    # : 1-e-hit
    ((1,2,3), (1,...,3), (2,3), (...,3)),
    ((2,3), (...,3), (3,), (3,)),
    ((3,), (3,), (), ()),
    # : 1-e-miss
    ((1,2,4), (1,...,3), (2,4), (...,3)),
    ((2,4), (...,3), (4,), (...,3,)),
    ((4,), (...,3), (4,), (3,)),
    ((4,), (3,), Miss, Miss),
    # : sparse-e-hit
    ((1,2,3,4,5,6,7), (1,...,4,...,7), (2,3,4,5,6,7), (...,4,...,7)),
    ((2,3,4,5,6,7), (...,4,...,7), (3,4,5,6,7), (...,4,...,7)),
    ((3,4,5,6,7), (...,4,...,7), (4,5,6,7), (4,...,7)),
    ((4,5,6,7), (4,...,7), (5,6,7), (...,7)),
    ((5,6,7), (...,7), (6,7), (...,7)),
    ((6,7), (...,7), (7,), (7,)),
    ((7,), (7,), (), ()),
    # : e-last-elem-hit
    # : e-last-elem-miss
)  # yapf: disable
def test_move(l, p, xl, xp) -> None:
    "Should move"
    assert move(l, p) == (xl, xp)


@pytest.mark.slow
@given(diff_ints(40))  # nb: way above practicality for matching many values
def test_matches_unary_hit(nums):
    assert matches(nums, (nums, ))


@fixture.params(
    "value, pattern",
    (1, 2),
    ((1, 2), ((1, 2, 3), )),
    ((1, 3), ((Any, 4), )),
    ([1, 3], [Any, 4]),
)
def test_matches_unary_miss_known(value: Any, pattern: Any) -> None:
    "Trivial known misses, not generated by Hypothesis."
    assert matches(value, pattern) == Miss


@pytest.mark.slow
@given(differs=diff_ints(20))  # nb: also well above practival lengths
@settings(deadline=300)
def test_matches_unary_miss(differs: Iterable[int]):
    a, b = differs[0:10], differs[11:20]
    assert matches(a, b) == Miss


@pytest.mark.slow
@given(diff_ints(3), between(0, 2))
def test_matches_unary_wildcard_hit(nums, idx):
    miss, wk = nums[0:3], nums[:]
    miss[idx] = miss[idx] + 1
    wk[idx] = Any
    assert matches(miss, (wk, ))


@pytest.mark.slow
@given(diff_ints(12), between(0, 4))
@settings(deadline=300)
def test_matches_unary_wildcard_miss(differs: Iterable[int],
                                     wk: Iterable[int]):
    one, different = differs[0:5], differs[6:11]
    different[wk] = Any
    assert matches(one, different) == Miss


@fixture.params("value, pattern",
      (1, 1,),
      ('x', 'x'),
    ( (1,2,3,4,5), ((1,...,5),) ), # *1-e*
    ( (1,2,3,4,5,6,7,8), ((1,2,3,...,8),) ),  # *multi-e*
    ( (1,2,3,4,5),((1,2,3,4,...),) ),
    ( (1,2,3,4,5,6,7,8), ((1,2,3,...,5,...,8),) )
)  # yapf: disable
def test_matches_nary_hits(value: Any, pattern: Iterable) -> None:
    "Should match known values existing in known iterables."
    assert matches(value, pattern) == unbox(pattern)


@fixture.params("value, pattern",
      (1, (3,4) ),
    ( (1,2,3,4,10), ((1,...,5),) ),
    ( (1,2,2,4,5,6,7,8), ((1,2,3,...,8),) ),
    ( (1,2,3,4,5,6,7,9), ((1,2,3,...,8),) ),
    ( (1,2,2,4,5,6,7,8), ((1,2,3,...,5,...,8),) ),
    ( (1,2,3,4,5,6,7,10), ((1,2,3,...,5,...,8),) ),
)  # yapf: disable
def test_matches_nary_miss(value: Any, pattern: Iterable) -> None:
    "Should match known values absent from known iterables."
    assert matches(value, pattern) == Miss


@pytest.fixture
def empty_matcher():
    return TypeMatcher()


class ASupertype:
    "A generic object type."


class ASubtype(ASupertype):
    "A subclass type for ASupertype."


class AnotherSubtype(ASupertype):
    "Another subclass type for ASupertype."


class Unrelated:
    "An object type with no superclass"


@pytest.fixture
def tmatch() -> TypeMatcher:
    "A fixture for type matches."

    matcher = TypeMatcher({
        int: (lambda x: x + 4),
        str: (lambda s: f"Hello, {s}!"),
        (int, str): (lambda amount, chr_: amount * chr_),
        (int, Any): (lambda amount, x: [x for n in range(amount)]),
        (int, int, int): lambda a,b,c: [matcher(a), matcher(b), matcher(c)],
        ASupertype: lambda x: f"super: {x.__class__.__name__}",
        ASubtype: lambda x: f"spec: subtype"
    })  # yapf: disable

    @matcher.case
    def its_a_float(x: float):
        return x - 1.1

    @matcher.case
    def superspecial_float_substraction(x: float, y: float, present: str):
        return present.format(x + y)

    @matcher.case
    def only_kwargs(**kwargs: Any):
        return kwargs['x'] + 3

    @matcher.case
    def sum_variadic_only(a: int, b: int, *c: int):
        return sum(c)

    @matcher.case
    def mix(a: str, b: str, *pos: Any, **kw: Any):
        return sum(pos) + sum(kw.values())

    return matcher


def test_tmatch_simple_conflict(tmatch) -> None:
    "Should tmatch_conflict"

    with pytest.raises(Conflict):

        @tmatch.case
        def _(x: int):
            return x


@fixture.params("positional, keyword, expected",
    ( ('x',),                {},      'Hello, x!' ),
    ( (2,),                  {},      6 ),
    ( ((2, 'x'),),           {},      'xx' ),
    ( ((2, [1]),),           {},      [[1], [1]] ),
    ( (2.2,),                {},      1.1 ),
    ( ((1.0, 1.1, "={}") ),  {},      "=2.1" ),
    ( ((1,2,3,4,5),),        {},      12 ), # sum_variadic_only
    ( (),                    {'x':1}, 4 ), # only_kwargs
    ( ('a', 'b', 1, 1),      {'c':1}, 3 ), # mix
    ( ([1],),                {},      Mismatch),  # NB: fails type only
    ( (ASupertype(),),       {},      "super: ASupertype"),
    ( (ASubtype(),),         {},      "spec: subtype"),
    ( (AnotherSubtype(),),   {},      "super: AnotherSubtype"),
    ( (Unrelated(),),        {},      Mismatch),
    ( (1,2,3),               {},      [5,6,7] ),
)  # yapf: disable
def test_tmatch_integration(tmatch: TypeMatcher, positional, keyword,
                            expected) -> None:
    "Should hit known type matches and miss known misses."
    if expected is Mismatch:
        with pytest.raises(Mismatch):
            tmatch(*positional, **keyword) == expected
    else:
        assert tmatch(*positional, **keyword) == expected


def test_tmatch_default_decl() -> None:
    "Should handle unmatched calls if ´Miss` is defined when initialized"
    match = TypeMatcher({Miss: lambda *args, **kwargs: 'default'})
    assert match('lksflkjl', x=1) == 'default'


def test_tmatch_default_deco(tmatch: TypeMatcher) -> None:
    "Should handle unmatched calls if ´Miss` is defined via decorator"

    @tmatch.missed
    def default(*params, **kwargs):
        return 'default'

    assert tmatch('lksflkjl', x=1) == 'default'


@pytest.fixture
def vmatch() -> ValueMatcher:
    "A fixture for value matches."
    vm = ValueMatcher({
        'x': same,
        ('x', 'y'): same,
        'a0': (lambda: 'a0'),
        (Any, '+', Any): same,
    })

    @vm.case(1, 2, 3)
    def one_two_three(one: int, two: int, three: int) -> str:
        return (one, two, three)

    @vm.case(10, 20, ..., 100)
    def start_ten_end_hundred(ten: int, twenty: int, *params: int):
        return sum(params)

    @vm.case(0, ..., Mapping)
    def one_param_and_varying(minus: int, *params: int, **kwargs: int):
        return sum(params) + sum(kwargs.values())

    return vm


def test_vmatch_simple_conflict(vmatch: ValueMatcher) -> None:
    "Should vmatch_simple_conflict"
    with pytest.raises(Conflict):

        @vmatch.case(1, 2, 3)
        def _(*args):
            return args


@fixture.params("params, keyword, expected",
    ( ('x',),            {},      'x' ),
    ( ('a',),            {},      Mismatch ),
    ( (1,),              {},      Mismatch ),
    ( ('x', 'y'),        {},      ('x', 'y') ),
    ( ('a0',),           {},      'a0' ),
    ( (1, 2, 3),         {},      (1,2,3)  ),
    ( (1, '+', 2),       {},      (1, '+', 2)  ),
    ( (0, 1, 1),         {'x':1}, 3  ),
    ( (0, 1, 1),         {},      Mismatch ),
    ( (10, 20, 30, 100), {},      130  ),
    ( (10, 20, 30, 200), {},      Mismatch  ),
)  # yapf: disable
def test_vmatch_integration(vmatch, params, keyword, expected) -> None:
    "Should hit known value matches and miss known misses."
    if expected is Mismatch:
        with pytest.raises(Mismatch):
            vmatch(*params, **keyword)
    else:
        assert vmatch(*params, **keyword) == expected


def test_vmatch_missed_decl() -> None:
    "Should handle unmatched calls if ´Miss` is defined when initialized"
    match = TypeMatcher({Miss: lambda *args, **kwargs: 'default'})
    assert match('lksflkjl', x=1) == 'default'


def test_vmatch_missed_deco(vmatch: ValueMatcher) -> None:
    "Should handle unmatched calls if ´Miss` is defined via decorator"

    @vmatch.missed
    def default(*params, **kwargs):
        return 'default'

    assert vmatch('lksflkjl', x=1) == 'default'


@fixture.doctest(TypeMatcher)
def test_TypeMatcher_docstrings(doctest) -> None:
    "Should "
    res = doctest()
    assert res == '', res


@fixture.doctest(ValueMatcher)
def test_ValueMatcher_docstrings(doctest) -> None:
    "Should "
    res = doctest()
    assert res == '', res
