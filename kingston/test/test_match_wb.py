# yapf

import pytest

from string import printable

from typing import Any, Iterable, Union, Tuple, Generic, TypeVar

from hypothesis import given
from hypothesis import strategies as st
from hypothesis import settings

from kingston.testing import fixture
from kingston.dig import dig

import funcy
from funcy import flow

from kingston.match import (Match, VMatch, Mismatch, Malformed, matches, match,
                            Conflict)

from kingston.testing import (between, ints, diff_ints, int_or_none, idx, same)

pytestmark = pytest.mark.wbox


@fixture.params(
    "value, pattern, expected",
    (1, 1, 1),
    (1, Any, 1),
    ('x', 1, ()),
    (1.1, 1, ()),
    (object(), 1, ()),
    (Match(), 1, ()),
    ((1,2,3), (1,2,3), (1,2,3)),
)  # yapf: disable
def test_match1(value, pattern, expected) -> None:
    "Should match_hit"
    match(value, pattern) == expected


@pytest.mark.slow
@given(diff_ints(40))  # nb: way above practicality for matching many values
def test_matches_unary_hit(nums):
    assert matches(nums, nums)


@fixture.params(
    "value, pattern",
    (1, 2),
    ((1, 2), (1, 2, 3)),
    ((1, 3), (Any, 4)),
    ([1, 3], [Any, 4]),
)
def test_matches_unary_miss_known(value: Any, pattern: Any) -> None:
    "Trivial known misses, not generated by Hypothesis."
    with pytest.raises(Mismatch):
        x = matches(value, pattern)


@pytest.mark.slow
@given(differs=diff_ints(20))  # nb: also well above practival lengths
@settings(deadline=300)
def test_matches_unary_miss(differs: Iterable[int]):
    a, b = differs[0:10], differs[11:20]
    with pytest.raises(Mismatch):
        matches(a, b)


@pytest.mark.slow
@given(diff_ints(3), between(0, 2))
def test_matches_unary_wildcard_hit(nums, idx):
    miss, wk = nums[0:3], nums[:]
    miss[idx] = miss[idx] + 1
    wk[idx] = Any
    assert matches(miss, wk)


@pytest.mark.slow
@given(diff_ints(12), between(0, 4))
@settings(deadline=300)
def test_matches_unary_wildcard_miss(differs: Iterable[int],
                                     wk: Iterable[int]):
    one, different = differs[0:5], differs[6:11]
    different[wk] = Any
    with pytest.raises(Mismatch):
        matches(one, different)


@fixture.params("value, pattern",
                (1, 1,),
                ('x', 'x'),
                )  # yapf: disable
def test_matches_nary_hits(value: Any, pattern: Iterable) -> None:
    "Should match known values existing in known iterables."
    assert matches(value, pattern) == pattern


@fixture.params("value, pattern",
                (1, (3,4)),
                )  # yapf: disable
def test_matches_nary_miss(value: Any, pattern: Iterable) -> None:
    "Should match known values absent from known iterables."


@pytest.fixture
def tmatch() -> Match:
    "A fixture for type matches."
    matcher = Match({
        int: lambda x: x + 4,
        str: lambda s: f"Hello, {s}!",
        (int, str): (lambda amount, chr_: amount * chr_),
        (int, Any): (lambda amount, x: [x for n in range(amount)])
    })

    @matcher.case
    def its_a_float(x: float):
        return x - 1.1

    @matcher.case
    def superspecial_float_substraction(x: float, y: float, present: str):
        return present.format(x + y)

    return matcher


def test_tmatch_simple_conflict(tmatch) -> None:
    "Should tmatch_conflict"

    with pytest.raises(Conflict):

        @tmatch.case
        def _(x: int):
            return x


@pytest.mark.parametrize("value, expected", (
    ('x', 'Hello, x!'),
    (2, 6),
    ((2, '*'), '**'),
    ((2, [1]), [[1], [1]]),
    (2.2, 1.1),
    ((1.0, 1.1, "Result {}."), "Result 2.1."),
))  # yapf: disable
def test_tmatch_hits(tmatch: Match, value, expected) -> None:
    "Should hit known values"
    assert tmatch(value) == expected


@pytest.fixture
def vmatch() -> VMatch:
    "A fixture for value matches."
    vm = VMatch({
        'x': same,
        ('x', 'y'): same,
        'a0': (lambda: 'a0'),
        (Any, '+', Any): same,
    })

    @vm.case(1, 2, 3)
    def one_two_three(one: int, two: int, three: int) -> str:
        return (one, two, three)

    return vm


def test_vmatch_simple_conflict(vmatch: VMatch) -> None:
    "Should vmatch_simple_conflict"
    with pytest.raises(Conflict):

        @vmatch.case(1, 2, 3)
        def _(*args):
            return args


@pytest.mark.parametrize("param", (
    'x',
    ('x', 'y'),
    2,
    'a0',
    (1, '+', 1),
    (2.2, 1.1),
))  # yapf: disable
def test_vmatch_hits(vmatch, param) -> None:
    "Should hit known values"
    assert vmatch(param) == param


@pytest.mark.parametrize("param", (
    'x',
    ('x', 'y'),
    'a0',
    (1, 2, 3),
    (1, '+', 2),
))  # yapf: disable
def test_vmatch_hits(vmatch, param) -> None:
    "Should hit known values"
    assert vmatch(param) == param


@pytest.mark.parametrize("param", (
    'a',
    ('x', 'y', 'z'),
    1,
    0,
))  # yapf: disable
def test_vmatch_misses(vmatch, param) -> None:
    "Should miss values known not to be present."
    with pytest.raises(Mismatch):
        vmatch(param)
